// This file was autogenerated by parse_grammar.lua from pony.ebnf.

/*
 * inline constants: 
 * BINARY          := [0-1]
 * CHAR_CHAR       := '\\' "'" | ($CHAR_ESC)
 | [^'\\]

 *     ('\\' "'" | ('\\' ('a' | 'b' | 'e' | 'f' | 'n' | 'r' | 't' | 'v' | '\\' | '0') | ('\\' 'x' ([0-9a-fA-F]) ([0-9a-fA-F]))
)
 | [^'\\]
)
 * CHAR_ESC        := '\\' ('a' | 'b' | 'e' | 'f' | 'n' | 'r' | 't' | 'v' | '\\' | '0') | ($HEX_ESC)

 *     ('\\' ('a' | 'b' | 'e' | 'f' | 'n' | 'r' | 't' | 'v' | '\\' | '0') | ('\\' 'x' ([0-9a-fA-F]) ([0-9a-fA-F]))
)
 * CLASSDEF        := interface | trait
 | primitive
 | struct
 | class
 | actor

 * CLASS_COMMON    := annotations? '@'? cap? (identifier: name) typeparams? ('is' type)? ((string? field* ($METHOD)*): body)
 *     (annotations? '@'? cap? (identifier: name) typeparams? ('is' type)? ((string? field* (function | behavior
 | constructor
)*): body))
 * DIGIT           := [0-9]
 * ENTITY          := typealias | ($CLASSDEF)

 *     (typealias | (interface | trait
 | primitive
 | struct
 | class
 | actor
)
)
 * ESC             := ($CHAR_ESC) | ($UNICODE_ESC)
 | ($UNICODE2_ESC)

 *     (('\\' ('a' | 'b' | 'e' | 'f' | 'n' | 'r' | 't' | 'v' | '\\' | '0') | ('\\' 'x' ([0-9a-fA-F]) ([0-9a-fA-F]))
) | ('\\' 'u' ([0-9a-fA-F]) ([0-9a-fA-F]) ([0-9a-fA-F]) ([0-9a-fA-F]))
 | ('\\' 'U' ([0-9a-fA-F]) ([0-9a-fA-F]) ([0-9a-fA-F]) ([0-9a-fA-F]) ([0-9a-fA-F]) ([0-9a-fA-F]))
)
 * EXP             := >(('e' | 'E') ('+' | '-')? (($DIGIT) | '_')+)
 *     (>(('e' | 'E') ('+' | '-')? (([0-9]) | '_')+))
 * HEX             := [0-9a-fA-F]
 * HEX_ESC         := '\\' 'x' ($HEX) ($HEX)
 *     ('\\' 'x' ([0-9a-fA-F]) ([0-9a-fA-F]))
 * LAMBDATYPE      := '{' cap? identifier? typeparams? lambdatypes (':' type)? '?'? '}' (cap | gencap)? ('^' | '!')?
 * LETTER          := [a-zA-Z]
 * METHOD          := function | behavior
 | constructor

 * METHOD_COMMON   := annotations? (cap | '@')? (identifier: name) typeparams? methodparams (':' type)? '?'? string? ('=>' (rawseq: body))?
 * STRING_CHAR     := '\\' '"' | ($ESC)
 | [^"\\]

 *     ('\\' '"' | (('\\' ('a' | 'b' | 'e' | 'f' | 'n' | 'r' | 't' | 'v' | '\\' | '0') | ('\\' 'x' ([0-9a-fA-F]) ([0-9a-fA-F]))
) | ('\\' 'u' ([0-9a-fA-F]) ([0-9a-fA-F]) ([0-9a-fA-F]) ([0-9a-fA-F]))
 | ('\\' 'U' ([0-9a-fA-F]) ([0-9a-fA-F]) ([0-9a-fA-F]) ([0-9a-fA-F]) ([0-9a-fA-F]) ([0-9a-fA-F]))
)
 | [^"\\]
)
 * TRAIT_COMMON    := annotations? '@'? cap? (identifier: name) typeparams? ('is' type)? ((string? ($METHOD)*): body)
 *     (annotations? '@'? cap? (identifier: name) typeparams? ('is' type)? ((string? (function | behavior
 | constructor
)*): body))
 * UNICODE2_ESC    := '\\' 'U' ($HEX) ($HEX) ($HEX) ($HEX) ($HEX) ($HEX)
 *     ('\\' 'U' ([0-9a-fA-F]) ([0-9a-fA-F]) ([0-9a-fA-F]) ([0-9a-fA-F]) ([0-9a-fA-F]) ([0-9a-fA-F]))
 * UNICODE_ESC     := '\\' 'u' ($HEX) ($HEX) ($HEX) ($HEX)
 *     ('\\' 'u' ([0-9a-fA-F]) ([0-9a-fA-F]) ([0-9a-fA-F]) ([0-9a-fA-F]))
 */

module.exports = grammar({
  name: 'pony',

  /*
   * pony.ebnf:1
   * extras              ::= { /[\u0020\u0009\u000D\u000A]/ linecomment nestedcomment }
   */
  extras: $ => [/[\u0020\u0009\u000D\u000A]/, $.linecomment, $.nestedcomment],
  /*
   * pony.ebnf:3-20
   * conflicts           ::= {
   *                         { useexpr }
   *                         { binop unaryop }
   *                         { lambdatypes lambdaparams }
   *                         { nominal lambdaparam }
   *                         { nominal atom }
   *                         { term atom }
   *                         { term casepattern }
   *                         { term postfix }
   *                         { term assignment }
   *                         { atom casepattern }
   *                         { atom atomtype }
   *                         { unaryop casepattern }
   *                         { infix consume }
   *                         { infix }
   *                         { positional parenterm }
   *                         { tuple }
   *                       }
   */
  conflicts: $ => [
                    [$.useexpr],
                    [$.binop, $.unaryop],
                    [$.lambdatypes, $.lambdaparams],
                    [$.nominal, $.lambdaparam],
                    [$.nominal, $.atom],
                    [$.term, $.atom],
                    [$.term, $.casepattern],
                    [$.term, $.postfix],
                    [$.term, $.assignment],
                    [$.atom, $.casepattern],
                    [$.atom, $.atomtype],
                    [$.unaryop, $.casepattern],
                    [$.infix, $.consume],
                    [$.infix],
                    [$.positional, $.parenterm],
                    [$.tuple]
                  ],
  /*
   * pony.ebnf:22
   * word                ::= identifier
   */
  word: $ => $.identifier,
  rules: {
    /*
     * pony.ebnf:26
     * module            ::= string? use* ($ENTITY)*
     */
    module: $ => seq(
                   optional($.string),
                   repeat($.use),
                   repeat(
                     choice($.typealias, $.interface, $.trait, $.primitive, $.struct, $.class, $.actor)
                   )
                 ),
    /*
     * pony.ebnf:28
     * use               ::= 'use' (identifier '=')? (string | useffi) ('if' usecondition)?
     */
    use: $ => seq(
                'use',
                optional(seq($.identifier, '=')),
                choice($.string, $.useffi),
                optional(seq('if', $.usecondition))
              ),
    /*
     * pony.ebnf:30
     * useffi            ::= '@' (identifier | string) typeargs '(' params? ')' '?'?
     */
    useffi: $ => seq(
                   '@',
                   choice($.identifier, $.string),
                   $.typeargs,
                   '(',
                   optional($.params),
                   ')',
                   optional('?')
                 ),
    /*
     * pony.ebnf:32-35
     * usecondition      ::= useexpr
     *                     | useexpr 'and' useexpr
     *                     | useexpr 'or' useexpr
     *                     | useexpr 'xor' useexpr
     */
    usecondition: $ => choice(
                         $.useexpr,
                         seq($.useexpr, 'and', $.useexpr),
                         seq($.useexpr, 'or', $.useexpr),
                         seq($.useexpr, 'xor', $.useexpr)
                       ),
    /*
     * pony.ebnf:37-47
     * useexpr           ::= string
     *                     | buildplatforms
     *                     | 'not' buildplatforms
     *                     | 'not' string
     *                     | '(' useexpr ')'
     *                     | useexpr 'and' buildplatforms
     *                     | useexpr 'and' string
     *                     | useexpr 'or' buildplatforms
     *                     | useexpr 'or' string
     *                     | useexpr 'xor' buildplatforms
     *                     | useexpr 'xor' string
     * 
     */
    useexpr: $ => choice(
                    $.string,
                    $.buildplatforms,
                    seq('not', $.buildplatforms),
                    seq('not', $.string),
                    seq('(', $.useexpr, ')'),
                    seq($.useexpr, 'and', $.buildplatforms),
                    seq($.useexpr, 'and', $.string),
                    seq($.useexpr, 'or', $.buildplatforms),
                    seq($.useexpr, 'or', $.string),
                    seq($.useexpr, 'xor', $.buildplatforms),
                    seq($.useexpr, 'xor', $.string)
                  ),
    /*
     * pony.ebnf:49-68
     * buildplatforms    ::= 'bsd'
     *                     | 'freebsd'
     *                     | 'dragonfly'
     *                     | 'openbsd'
     *                     | 'linux'
     *                     | 'osx'
     *                     | 'posix'
     *                     | 'windows'
     *                     | 'x86'
     *                     | 'arm'
     *                     | 'riscv'
     *                     | 'lp64'
     *                     | 'llp64'
     *                     | 'ilp32'
     *                     | 'bigendian'
     *                     | 'littleendian'
     *                     | 'native128'
     *                     | 'debug'
     *                     | 'runtimestats'
     *                     | 'runtimestatsmessages'
     */
    buildplatforms: $ => choice(
                           'bsd',
                           'freebsd',
                           'dragonfly',
                           'openbsd',
                           'linux',
                           'osx',
                           'posix',
                           'windows',
                           'x86',
                           'arm',
                           'riscv',
                           'lp64',
                           'llp64',
                           'ilp32',
                           'bigendian',
                           'littleendian',
                           'native128',
                           'debug',
                           'runtimestats',
                           'runtimestatsmessages'
                         ),
    /*
     * pony.ebnf:70
     * typeargs          ::= '[' type (',' type)* ']'
     */
    typeargs: $ => seq('[', $.type, repeat(seq(',', $.type)), ']'),
    /*
     * pony.ebnf:72
     * type              ::= atomtype ('->' type)?
     */
    type: $ => seq($.atomtype, optional(seq('->', $.type))),
    /*
     * pony.ebnf:74-79
     * atomtype          ::= 'this'
     *                     | cap
     *                     | '(' infixtype tupletype? ')'
     *                     | nominal
     *                     | lambdatype
     *                     | barelambdatype
     */
    atomtype: $ => choice(
                     'this',
                     $.cap,
                     seq('(', $.infixtype, optional($.tupletype), ')'),
                     $.nominal,
                     $.lambdatype,
                     $.barelambdatype
                   ),
    /*
     * pony.ebnf:81
     * infixtype         ::= type (uniontype | isecttype)*
     */
    infixtype: $ => seq($.type, repeat(choice($.uniontype, $.isecttype))),
    /*
     * pony.ebnf:83
     * uniontype         ::= '|' type
     */
    uniontype: $ => seq('|', $.type),
    /*
     * pony.ebnf:85
     * isecttype         ::= '&' type
     */
    isecttype: $ => seq('&', $.type),
    /*
     * pony.ebnf:87
     * tupletype         ::= (',' infixtype)+
     */
    tupletype: $ => repeat1(seq(',', $.infixtype)),
    /*
     * pony.ebnf:89
     * nominal           ::= >(((identifier ('.' identifier)?): name) typeargs? (cap | gencap)? ('^' | '!')?)
     */
    nominal: $ => prec.right(
                    seq(
                      field('name', seq($.identifier, optional(seq('.', $.identifier)))),
                      optional($.typeargs),
                      optional(choice($.cap, $.gencap)),
                      optional(choice('^', '!'))
                    )
                  ),
    /*
     * pony.ebnf:91-95
     * gencap            ::= '#read'
     *                     | '#send'
     *                     | '#share'
     *                     | '#alias'
     *                     | '#any'
     */
    gencap: $ => choice('#read', '#send', '#share', '#alias', '#any'),
    /*
     * pony.ebnf:97-102
     * cap               ::= 'iso'
     *                     | 'trn'
     *                     | 'ref'
     *                     | 'val'
     *                     | 'box'
     *                     | 'tag'
     */
    cap: $ => choice('iso', 'trn', 'ref', 'val', 'box', 'tag'),
    /*
     * pony.ebnf:104
     * lambdatype        ::= ($LAMBDATYPE)
     */
    lambdatype: $ => seq(
                       '{',
                       optional($.cap),
                       optional($.identifier),
                       optional($.typeparams),
                       $.lambdatypes,
                       optional(seq(':', $.type)),
                       optional('?'),
                       '}',
                       optional(choice($.cap, $.gencap)),
                       optional(choice('^', '!'))
                     ),
    /*
     * pony.ebnf:106
     * barelambdatype    ::= '@' ($LAMBDATYPE)
     */
    barelambdatype: $ => seq(
                           '@',
                           seq(
                             '{',
                             optional($.cap),
                             optional($.identifier),
                             optional($.typeparams),
                             $.lambdatypes,
                             optional(seq(':', $.type)),
                             optional('?'),
                             '}',
                             optional(choice($.cap, $.gencap)),
                             optional(choice('^', '!'))
                           )
                         ),
    /*
     * pony.ebnf:110
     * lambdatypes       ::= '(' (type (',' type)*)? ')'
     */
    lambdatypes: $ => seq('(', optional(seq($.type, repeat(seq(',', $.type)))), ')'),
    /*
     * pony.ebnf:112
     * typeparams        ::= '[' typeparam (',' typeparam)* ']'
     */
    typeparams: $ => seq('[', $.typeparam, repeat(seq(',', $.typeparam)), ']'),
    /*
     * pony.ebnf:114
     * typeparam         ::= (identifier: name) (':' type)? ('=' typearg)?
     */
    typeparam: $ => seq(
                      field('name', $.identifier),
                      optional(seq(':', $.type)),
                      optional(seq('=', $.typearg))
                    ),
    /*
     * pony.ebnf:116-119
     * typearg           ::= type
     *                     | literal
     *                     | '#' postfix
     *                     | typeargs
     */
    typearg: $ => choice($.type, $.literal, seq('#', $.postfix), $.typeargs),
    /*
     * pony.ebnf:121
     * params            ::= (param | '...') (',' (param | '...'))*
     */
    params: $ => seq(choice($.param, '...'), repeat(seq(',', choice($.param, '...')))),
    /*
     * pony.ebnf:123
     * param             ::= (identifier: name) ':' type ('=' term)?
     */
    param: $ => seq(field('name', $.identifier), ':', $.type, optional(seq('=', $.term))),
    /*
     * pony.ebnf:125
     * lambdaparams      ::= '(' (lambdaparam (',' lambdaparam)*)? ')'
     */
    lambdaparams: $ => seq('(', optional(seq($.lambdaparam, repeat(seq(',', $.lambdaparam)))), ')'),
    /*
     * pony.ebnf:127
     * lambdaparam       ::= (identifier: name) (':' type)? ('=' term)?
     */
    lambdaparam: $ => seq(
                        field('name', $.identifier),
                        optional(seq(':', $.type)),
                        optional(seq('=', $.term))
                      ),
    /*
     * pony.ebnf:129
     * lambdacaptures    ::= '(' (lambdacapture | 'this') (',' (lambdacapture | 'this'))* ')'
     */
    lambdacaptures: $ => seq(
                           '(',
                           choice($.lambdacapture, 'this'),
                           repeat(seq(',', choice($.lambdacapture, 'this'))),
                           ')'
                         ),
    /*
     * pony.ebnf:131
     * lambdacapture     ::= (identifier: name) (':' type)? ('=' term)?
     */
    lambdacapture: $ => seq(
                          field('name', $.identifier),
                          optional(seq(':', $.type)),
                          optional(seq('=', $.term))
                        ),
    /*
     * pony.ebnf:133-145
     * atom              ::= identifier
     *                     | 'this'
     *                     | '__loc'
     *                     | literal
     *                     | tuple
     *                     | array
     *                     | object
     *                     | if
     *                     | while
     *                     | for
     *                     | lambda
     *                     | barelambda
     *                     | fficall
     */
    atom: $ => choice(
                 $.identifier,
                 'this',
                 '__loc',
                 $.literal,
                 $.tuple,
                 $.array,
                 $.object,
                 $.if,
                 $.while,
                 $.for,
                 $.lambda,
                 $.barelambda,
                 $.fficall
               ),
    /*
     * pony.ebnf:147-163
     * term              ::= consume
     *                     | recover
     *                     | if
     *                     | ifdef
     *                     | iftype
     *                     | try
     *                     | while
     *                     | repeat
     *                     | for
     *                     | match
     *                     | with
     *                     | pattern
     *                     | postfix
     *                     | infix
     *                     | atom
     *                     | 2(unaryop term)
     *                     | parenterm
     */
    term: $ => choice(
                 $.consume,
                 $.recover,
                 $.if,
                 $.ifdef,
                 $.iftype,
                 $.try,
                 $.while,
                 $.repeat,
                 $.for,
                 $.match,
                 $.with,
                 $.pattern,
                 $.postfix,
                 $.infix,
                 $.atom,
                 prec(2, seq($.unaryop, $.term)),
                 $.parenterm
               ),
    /*
     * pony.ebnf:165
     * parenterm         ::= '(' rawseq ')'
     */
    parenterm: $ => seq('(', $.rawseq, ')'),
    /*
     * pony.ebnf:167-168
     * rawseq            ::= exprseq
     *                     | jump
     */
    rawseq: $ => choice($.exprseq, $.jump),
    /*
     * pony.ebnf:170-171
     * exprseq           ::= assignment (semiexpr | nosemi)?
     *                     | term (semiexpr | nosemi)?
     */
    exprseq: $ => choice(
                    seq($.assignment, optional(choice($.semiexpr, $.nosemi))),
                    seq($.term, optional(choice($.semiexpr, $.nosemi)))
                  ),
    /*
     * pony.ebnf:173-174
     * nosemi            ::= exprseq
     *                     | jump
     */
    nosemi: $ => choice($.exprseq, $.jump),
    /*
     * pony.ebnf:176
     * semiexpr          ::= ';' (exprseq | jump)
     */
    semiexpr: $ => seq(';', choice($.exprseq, $.jump)),
    /*
     * pony.ebnf:178
     * assignment        ::= <(infix | term) '=' >(term | assignment)
     */
    assignment: $ => seq(
                       prec.left(choice($.infix, $.term)),
                       '=',
                       prec.right(choice($.term, $.assignment))
                     ),
    /*
     * pony.ebnf:180-185
     * jump              ::= return
     *                     | break
     *                     | continue
     *                     | error
     *                     | compile_intrinsic
     *                     | compile_error
     */
    jump: $ => choice($.return, $.break, $.continue, $.error, $.compile_intrinsic, $.compile_error),
    /*
     * pony.ebnf:187
     * tuple             ::= '(' rawseq ',' rawseq (',' rawseq)* ')'
     */
    tuple: $ => seq('(', $.rawseq, ',', $.rawseq, repeat(seq(',', $.rawseq)), ')'),
    /*
     * pony.ebnf:189
     * return            ::= <('return' rawseq?)
     */
    return: $ => prec.left(seq('return', optional($.rawseq))),
    /*
     * pony.ebnf:191
     * break             ::= <('break' rawseq?)
     */
    break: $ => prec.left(seq('break', optional($.rawseq))),
    /*
     * pony.ebnf:193
     * continue          ::= <('continue' rawseq?)
     */
    continue: $ => prec.left(seq('continue', optional($.rawseq))),
    /*
     * pony.ebnf:195
     * error             ::= <('error' rawseq?)
     */
    error: $ => prec.left(seq('error', optional($.rawseq))),
    /*
     * pony.ebnf:197
     * compile_intrinsic ::= <('compile_intrinsic' rawseq?)
     */
    compile_intrinsic: $ => prec.left(seq('compile_intrinsic', optional($.rawseq))),
    /*
     * pony.ebnf:199
     * compile_error     ::= <('compile_error' rawseq?)
     */
    compile_error: $ => prec.left(seq('compile_error', optional($.rawseq))),
    /*
     * pony.ebnf:201-202
     * idseq             ::= identifier
     *                     | '(' identifier (',' identifier)* ')'
     */
    idseq: $ => choice($.identifier, seq('(', $.identifier, repeat(seq(',', $.identifier)), ')')),
    /*
     * pony.ebnf:204-234
     * binop             ::= 'and' '?'?
     *                     | 'or' '?'?
     *                     | 'xor' '?'?
     *                     | '+' '?'?
     *                     | '-' '?'?
     *                     | '*' '?'?
     *                     | '/' '?'?
     *                     | '%' '?'?
     *                     | '%%' '?'?
     *                     | '+~' '?'?
     *                     | '-~' '?'?
     *                     | '*~' '?'?
     *                     | '/~' '?'?
     *                     | '%~' '?'?
     *                     | '%%~' '?'?
     *                     | '<<' '?'?
     *                     | '>>' '?'?
     *                     | '<<~' '?'?
     *                     | '>>~' '?'?
     *                     | '==' '?'?
     *                     | '!=' '?'?
     *                     | '<' '?'?
     *                     | '<=' '?'?
     *                     | '>' '?'?
     *                     | '>=' '?'?
     *                     | '==~' '?'?
     *                     | '!=~' '?'?
     *                     | '<~' '?'?
     *                     | '<=~' '?'?
     *                     | '>~' '?'?
     *                     | '>=~' '?'?
     */
    binop: $ => choice(
                  seq('and', optional('?')),
                  seq('or', optional('?')),
                  seq('xor', optional('?')),
                  seq('+', optional('?')),
                  seq('-', optional('?')),
                  seq('*', optional('?')),
                  seq('/', optional('?')),
                  seq('%', optional('?')),
                  seq('%%', optional('?')),
                  seq('+~', optional('?')),
                  seq('-~', optional('?')),
                  seq('*~', optional('?')),
                  seq('/~', optional('?')),
                  seq('%~', optional('?')),
                  seq('%%~', optional('?')),
                  seq('<<', optional('?')),
                  seq('>>', optional('?')),
                  seq('<<~', optional('?')),
                  seq('>>~', optional('?')),
                  seq('==', optional('?')),
                  seq('!=', optional('?')),
                  seq('<', optional('?')),
                  seq('<=', optional('?')),
                  seq('>', optional('?')),
                  seq('>=', optional('?')),
                  seq('==~', optional('?')),
                  seq('!=~', optional('?')),
                  seq('<~', optional('?')),
                  seq('<=~', optional('?')),
                  seq('>~', optional('?')),
                  seq('>=~', optional('?'))
                ),
    /*
     * pony.ebnf:236-237
     * isop              ::= 'is'
     *                     | 'isnt'
     */
    isop: $ => choice('is', 'isnt'),
    /*
     * pony.ebnf:239-243
     * unaryop           ::= 'not'
     *                     | '-'
     *                     | '-~'
     *                     | 'addressof'
     *                     | 'digestof'
     */
    unaryop: $ => choice('not', '-', '-~', 'addressof', 'digestof'),
    /*
     * pony.ebnf:245-247
     * infix             ::= term binop term
     *                     | term isop term
     *                     | term 'as' type
     */
    infix: $ => choice(
                  seq($.term, $.binop, $.term),
                  seq($.term, $.isop, $.term),
                  seq($.term, 'as', $.type)
                ),
    /*
     * pony.ebnf:249-253
     * postfix           ::= access
     *                     | chain
     *                     | partial_apply
     *                     | call
     *                     | atom typeargs
     */
    postfix: $ => choice($.access, $.chain, $.partial_apply, $.call, seq($.atom, $.typeargs)),
    /*
     * pony.ebnf:255
     * access            ::= <3(term '.' term)
     */
    access: $ => prec.left(3, seq($.term, '.', $.term)),
    /*
     * pony.ebnf:257
     * chain             ::= <3(term '.>' term)
     */
    chain: $ => prec.left(3, seq($.term, '.>', $.term)),
    /*
     * pony.ebnf:259
     * partial_apply     ::= <3(term '~' term)
     */
    partial_apply: $ => prec.left(3, seq($.term, '~', $.term)),
    /*
     * pony.ebnf:261
     * call              ::= 4(term typeargs? callparams '?'?)
     */
    call: $ => prec(4, seq($.term, optional($.typeargs), $.callparams, optional('?'))),
    /*
     * pony.ebnf:263
     * callparams        ::= '(' positional? named? ')'
     */
    callparams: $ => seq('(', optional($.positional), optional($.named), ')'),
    /*
     * pony.ebnf:265
     * fficall           ::= '@' (string | identifier) typeargs? callparams '?'?
     */
    fficall: $ => seq(
                    '@',
                    choice($.string, $.identifier),
                    optional($.typeargs),
                    $.callparams,
                    optional('?')
                  ),
    /*
     * pony.ebnf:267
     * lambda            ::= '{' annotations? cap? identifier? typeparams? lambdaparams lambdacaptures? (':' type)? '?'? '=>' rawseq '}' cap?
     */
    lambda: $ => seq(
                   '{',
                   optional($.annotations),
                   optional($.cap),
                   optional($.identifier),
                   optional($.typeparams),
                   $.lambdaparams,
                   optional($.lambdacaptures),
                   optional(seq(':', $.type)),
                   optional('?'),
                   '=>',
                   $.rawseq,
                   '}',
                   optional($.cap)
                 ),
    /*
     * pony.ebnf:269
     * barelambda        ::= '@{' annotations? cap? identifier? typeparams? lambdaparams lambdacaptures? (':' type)? '?'? '=>' rawseq '}' cap?
     */
    barelambda: $ => seq(
                       '@{',
                       optional($.annotations),
                       optional($.cap),
                       optional($.identifier),
                       optional($.typeparams),
                       $.lambdaparams,
                       optional($.lambdacaptures),
                       optional(seq(':', $.type)),
                       optional('?'),
                       '=>',
                       $.rawseq,
                       '}',
                       optional($.cap)
                     ),
    /*
     * pony.ebnf:271
     * consume           ::= 'consume' cap? term
     */
    consume: $ => seq('consume', optional($.cap), $.term),
    /*
     * pony.ebnf:273
     * recover           ::= 'recover' annotations? cap? rawseq 'end'
     */
    recover: $ => seq('recover', optional($.annotations), optional($.cap), $.rawseq, 'end'),
    /*
     * pony.ebnf:275
     * if                ::= 'if' annotations? rawseq 'then' rawseq ('elseif' annotations? rawseq 'then' rawseq)* else? 'end'
     */
    if: $ => seq(
               'if',
               optional($.annotations),
               $.rawseq,
               'then',
               $.rawseq,
               repeat(seq('elseif', optional($.annotations), $.rawseq, 'then', $.rawseq)),
               optional($.else),
               'end'
             ),
    /*
     * pony.ebnf:277
     * ifdef             ::= 'ifdef' annotations? usecondition 'then' rawseq ('elseif' annotations? usecondition 'then' rawseq)* else? 'end'
     */
    ifdef: $ => seq(
                  'ifdef',
                  optional($.annotations),
                  $.usecondition,
                  'then',
                  $.rawseq,
                  repeat(seq('elseif', optional($.annotations), $.usecondition, 'then', $.rawseq)),
                  optional($.else),
                  'end'
                ),
    /*
     * pony.ebnf:279
     * iftype            ::= 'iftype' annotations? typecondition 'then' rawseq ('elseif' annotations? typecondition 'then' rawseq)* else? 'end'
     */
    iftype: $ => seq(
                   'iftype',
                   optional($.annotations),
                   $.typecondition,
                   'then',
                   $.rawseq,
                   repeat(seq('elseif', optional($.annotations), $.typecondition, 'then', $.rawseq)),
                   optional($.else),
                   'end'
                 ),
    /*
     * pony.ebnf:281
     * try               ::= 'try' annotations? rawseq ('else' annotations? rawseq)? ('then' annotations? rawseq)? 'end'
     */
    try: $ => seq(
                'try',
                optional($.annotations),
                $.rawseq,
                optional(seq('else', optional($.annotations), $.rawseq)),
                optional(seq('then', optional($.annotations), $.rawseq)),
                'end'
              ),
    /*
     * pony.ebnf:283
     * while             ::= 'while' annotations? rawseq 'do' rawseq else? 'end'
     */
    while: $ => seq(
                  'while',
                  optional($.annotations),
                  $.rawseq,
                  'do',
                  $.rawseq,
                  optional($.else),
                  'end'
                ),
    /*
     * pony.ebnf:285
     * repeat            ::= 'repeat' annotations? rawseq 'until' annotations? rawseq else? 'end'
     */
    repeat: $ => seq(
                   'repeat',
                   optional($.annotations),
                   $.rawseq,
                   'until',
                   optional($.annotations),
                   $.rawseq,
                   optional($.else),
                   'end'
                 ),
    /*
     * pony.ebnf:287
     * for               ::= 'for' annotations? (idseq: element) 'in' rawseq 'do' rawseq else? 'end'
     */
    for: $ => seq(
                'for',
                optional($.annotations),
                field('element', $.idseq),
                'in',
                $.rawseq,
                'do',
                $.rawseq,
                optional($.else),
                'end'
              ),
    /*
     * pony.ebnf:289
     * match             ::= 'match' annotations? rawseq case* else? 'end'
     */
    match: $ => seq(
                  'match',
                  optional($.annotations),
                  $.rawseq,
                  repeat($.case),
                  optional($.else),
                  'end'
                ),
    /*
     * pony.ebnf:291
     * with              ::= 'with' annotations? (idseq: name) '=' rawseq (',' (idseq: name) '=' rawseq)? 'do' rawseq 'end'
     */
    with: $ => seq(
                 'with',
                 optional($.annotations),
                 field('name', $.idseq),
                 '=',
                 $.rawseq,
                 optional(seq(',', field('name', $.idseq), '=', $.rawseq)),
                 'do',
                 $.rawseq,
                 'end'
               ),
    /*
     * pony.ebnf:293
     * object            ::= 'object' annotations? cap? ('is' type)? field* ($METHOD)* 'end'
     */
    object: $ => seq(
                   'object',
                   optional($.annotations),
                   optional($.cap),
                   optional(seq('is', $.type)),
                   repeat($.field),
                   repeat(choice($.function, $.behavior, $.constructor)),
                   'end'
                 ),
    /*
     * pony.ebnf:295
     * else              ::= 'else' annotations? rawseq
     */
    else: $ => seq('else', optional($.annotations), $.rawseq),
    /*
     * pony.ebnf:297
     * typecondition     ::= type '<:' type
     */
    typecondition: $ => seq($.type, '<:', $.type),
    /*
     * pony.ebnf:299
     * case              ::= '|' casepattern? ('if' rawseq)? ('=>' rawseq)?
     */
    case: $ => seq(
                 '|',
                 optional($.casepattern),
                 optional(seq('if', $.rawseq)),
                 optional(seq('=>', $.rawseq))
               ),
    /*
     * pony.ebnf:301-303
     * pattern           ::= 'var' (identifier: name) (':' type)?
     *                     | 'let' (identifier: name) (':' type)?
     *                     | 'embed' (identifier: name) (':' type)?
     */
    pattern: $ => choice(
                    seq('var', field('name', $.identifier), optional(seq(':', $.type))),
                    seq('let', field('name', $.identifier), optional(seq(':', $.type))),
                    seq('embed', field('name', $.identifier), optional(seq(':', $.type)))
                  ),
    /*
     * pony.ebnf:305-310
     * casepattern       ::= pattern
     *                     | literal
     *                     | '-' (int | float)
     *                     | identifier
     *                     | postfix
     *                     | tuplepattern
     */
    casepattern: $ => choice(
                        $.pattern,
                        $.literal,
                        seq('-', choice($.int, $.float)),
                        $.identifier,
                        $.postfix,
                        $.tuplepattern
                      ),
    /*
     * pony.ebnf:312
     * tuplepattern      ::= '(' casepattern (',' casepattern)* ')'
     */
    tuplepattern: $ => seq('(', $.casepattern, repeat(seq(',', $.casepattern)), ')'),
    /*
     * pony.ebnf:314
     * positional        ::= rawseq (',' rawseq)*
     */
    positional: $ => seq($.rawseq, repeat(seq(',', $.rawseq))),
    /*
     * pony.ebnf:316
     * named             ::= 'where' namedarg (',' namedarg)*
     */
    named: $ => seq('where', $.namedarg, repeat(seq(',', $.namedarg))),
    /*
     * pony.ebnf:318
     * namedarg          ::= identifier '=' term
     */
    namedarg: $ => seq($.identifier, '=', $.term),
    /*
     * pony.ebnf:323
     * typealias         ::= 'type' (identifier: name) typeparams? 'is' type string?
     */
    typealias: $ => seq(
                      'type',
                      field('name', $.identifier),
                      optional($.typeparams),
                      'is',
                      $.type,
                      optional($.string)
                    ),
    /*
     * pony.ebnf:332
     * interface         ::= 'interface' ($TRAIT_COMMON)
     */
    interface: $ => seq(
                      'interface',
                      seq(
                        optional($.annotations),
                        optional('@'),
                        optional($.cap),
                        field('name', $.identifier),
                        optional($.typeparams),
                        optional(seq('is', $.type)),
                        field(
                          'body',
                          seq(optional($.string), repeat(choice($.function, $.behavior, $.constructor)))
                        )
                      )
                    ),
    /*
     * pony.ebnf:334
     * trait             ::= 'trait' ($TRAIT_COMMON)
     */
    trait: $ => seq(
                  'trait',
                  seq(
                    optional($.annotations),
                    optional('@'),
                    optional($.cap),
                    field('name', $.identifier),
                    optional($.typeparams),
                    optional(seq('is', $.type)),
                    field(
                      'body',
                      seq(optional($.string), repeat(choice($.function, $.behavior, $.constructor)))
                    )
                  )
                ),
    /*
     * pony.ebnf:336
     * primitive         ::= 'primitive' ($TRAIT_COMMON)
     */
    primitive: $ => seq(
                      'primitive',
                      seq(
                        optional($.annotations),
                        optional('@'),
                        optional($.cap),
                        field('name', $.identifier),
                        optional($.typeparams),
                        optional(seq('is', $.type)),
                        field(
                          'body',
                          seq(optional($.string), repeat(choice($.function, $.behavior, $.constructor)))
                        )
                      )
                    ),
    /*
     * pony.ebnf:338
     * struct            ::= 'struct' ($CLASS_COMMON)
     */
    struct: $ => seq(
                   'struct',
                   seq(
                     optional($.annotations),
                     optional('@'),
                     optional($.cap),
                     field('name', $.identifier),
                     optional($.typeparams),
                     optional(seq('is', $.type)),
                     field(
                       'body',
                       seq(
                         optional($.string),
                         repeat($.field),
                         repeat(choice($.function, $.behavior, $.constructor))
                       )
                     )
                   )
                 ),
    /*
     * pony.ebnf:340
     * class             ::= 'class' ($CLASS_COMMON)
     */
    class: $ => seq(
                  'class',
                  seq(
                    optional($.annotations),
                    optional('@'),
                    optional($.cap),
                    field('name', $.identifier),
                    optional($.typeparams),
                    optional(seq('is', $.type)),
                    field(
                      'body',
                      seq(
                        optional($.string),
                        repeat($.field),
                        repeat(choice($.function, $.behavior, $.constructor))
                      )
                    )
                  )
                ),
    /*
     * pony.ebnf:342
     * actor             ::= 'actor' ($CLASS_COMMON)
     */
    actor: $ => seq(
                  'actor',
                  seq(
                    optional($.annotations),
                    optional('@'),
                    optional($.cap),
                    field('name', $.identifier),
                    optional($.typeparams),
                    optional(seq('is', $.type)),
                    field(
                      'body',
                      seq(
                        optional($.string),
                        repeat($.field),
                        repeat(choice($.function, $.behavior, $.constructor))
                      )
                    )
                  )
                ),
    /*
     * pony.ebnf:348
     * field             ::= >(pattern ('=' term)? string?)
     */
    field: $ => prec.right(seq($.pattern, optional(seq('=', $.term)), optional($.string))),
    /*
     * pony.ebnf:354
     * function          ::= 'fun' $METHOD_COMMON
     */
    function: $ => seq(
                     'fun',
                     optional($.annotations),
                     optional(choice($.cap, '@')),
                     field('name', $.identifier),
                     optional($.typeparams),
                     $.methodparams,
                     optional(seq(':', $.type)),
                     optional('?'),
                     optional($.string),
                     optional(seq('=>', field('body', $.rawseq)))
                   ),
    /*
     * pony.ebnf:356
     * behavior          ::= 'be' $METHOD_COMMON
     */
    behavior: $ => seq(
                     'be',
                     optional($.annotations),
                     optional(choice($.cap, '@')),
                     field('name', $.identifier),
                     optional($.typeparams),
                     $.methodparams,
                     optional(seq(':', $.type)),
                     optional('?'),
                     optional($.string),
                     optional(seq('=>', field('body', $.rawseq)))
                   ),
    /*
     * pony.ebnf:358
     * constructor       ::= 'new' $METHOD_COMMON
     */
    constructor: $ => seq(
                        'new',
                        optional($.annotations),
                        optional(choice($.cap, '@')),
                        field('name', $.identifier),
                        optional($.typeparams),
                        $.methodparams,
                        optional(seq(':', $.type)),
                        optional('?'),
                        optional($.string),
                        optional(seq('=>', field('body', $.rawseq)))
                      ),
    /*
     * pony.ebnf:362
     * methodparams      ::= '(' params? ')'
     */
    methodparams: $ => seq('(', optional($.params), ')'),
    /*
     * pony.ebnf:364-367
     * literal           ::= bool
     *                     | int
     *                     | float
     *                     | string
     */
    literal: $ => choice($.bool, $.int, $.float, $.string),
    /*
     * pony.ebnf:369
     * array             ::= '[' ('as' type ':')? rawseq? ']'
     */
    array: $ => seq('[', optional(seq('as', $.type, ':')), optional($.rawseq), ']'),
    /*
     * pony.ebnf:371
     * annotations       ::= ('\\' identifier (',' identifier)* '\\')
     */
    annotations: $ => seq('\\', $.identifier, repeat(seq(',', $.identifier)), '\\'),
    /*
     * pony.ebnf:373
     * identifier        ::= @([a-zA-Z_] (($LETTER) | ($DIGIT) | '_' | "'")*)
     */
    identifier: $ => token(seq(/[a-zA-Z_]/, repeat(choice(/[a-zA-Z]/, /[0-9]/, '_', "'")))),
    /*
     * pony.ebnf:375-376
     * bool              ::= 'true'
     *                     | 'false'
     */
    bool: $ => choice('true', 'false'),
    /*
     * pony.ebnf:378-381
     * int               ::= @(($DIGIT) ($DIGIT | '_')*)
     *                     | @('0x' (($HEX) | '_')+)
     *                     | @('0b' (($BINARY) | '_')+)
     *                     | @("'" ($CHAR_CHAR) "'")
     */
    int: $ => choice(
                token(seq(/[0-9]/, repeat(choice(/[0-9]/, '_')))),
                token(seq('0x', repeat1(choice(/[0-9a-fA-F]/, '_')))),
                token(seq('0b', repeat1(choice(/[0-1]/, '_')))),
                token(
                  seq(
                    "'",
                    choice(
                      seq('\\', "'"),
                      seq('\\', choice('a', 'b', 'e', 'f', 'n', 'r', 't', 'v', '\\', '0')),
                      seq('\\', 'x', /[0-9a-fA-F]/, /[0-9a-fA-F]/),
                      /[^'\\]/
                    ),
                    "'"
                  )
                )
              ),
    /*
     * pony.ebnf:383
     * float             ::= @(($DIGIT) (($DIGIT) | '_')* ('.' ($DIGIT) (($DIGIT) | '_')*)? ($EXP)?)
     */
    float: $ => token(
                  seq(
                    /[0-9]/,
                    repeat(choice(/[0-9]/, '_')),
                    optional(seq('.', /[0-9]/, repeat(choice(/[0-9]/, '_')))),
                    optional(
                      prec.right(seq(choice('e', 'E'), optional(choice('+', '-')), repeat1(choice(/[0-9]/, '_'))))
                    )
                  )
                ),
    /*
     * pony.ebnf:385-386
     * string            ::= @('"' ($STRING_CHAR)* '"')
     *                     | @('"""' (('"' | '""')? [^"])* '"""' '"'*)
     */
    string: $ => choice(
                   token(
                     seq(
                       '"',
                       repeat(
                         choice(
                           seq('\\', '"'),
                           seq('\\', choice('a', 'b', 'e', 'f', 'n', 'r', 't', 'v', '\\', '0')),
                           seq('\\', 'x', /[0-9a-fA-F]/, /[0-9a-fA-F]/),
                           seq('\\', 'u', /[0-9a-fA-F]/, /[0-9a-fA-F]/, /[0-9a-fA-F]/, /[0-9a-fA-F]/),
                           seq(
                             '\\',
                             'U',
                             /[0-9a-fA-F]/,
                             /[0-9a-fA-F]/,
                             /[0-9a-fA-F]/,
                             /[0-9a-fA-F]/,
                             /[0-9a-fA-F]/,
                             /[0-9a-fA-F]/
                           ),
                           /[^"\\]/
                         )
                       ),
                       '"'
                     )
                   ),
                   token(seq('"""', repeat(seq(optional(choice('"', '""')), /[^"]/)), '"""', repeat('"')))
                 ),
    /*
     * pony.ebnf:388
     * linecomment       ::= @('//' [^\u000A]* [\u000A])
     */
    linecomment: $ => token(seq('//', repeat(/[^\u000A]/), /[\u000A]/)),
    /*
     * pony.ebnf:390
     * nestedcomment     ::= '/*' (nestedcomment | '/' [^*] | '*'* [^*âˆ•])* '*'+ '/'
     */
    nestedcomment: $ => seq(
                          '/*',
                          repeat(choice($.nestedcomment, seq('/', /[^*]/), seq(repeat('*'), /[^*/]/))),
                          repeat1('*'),
                          '/'
                        )
  }
});
